using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using CsTsTypeGen.Utils;

namespace CsTsTypeGen.Core
{
    /// <summary>
    /// Main processor for generating TypeScript definitions from C# code
    /// </summary>
    public class TypeGenProcessor
    {
        /// <summary>
        /// Runs the TypeScript definition generation process
        /// </summary>
        /// <param name="inputDir">Directory containing C# source files</param>
        /// <param name="outputPath">Path where TypeScript definitions will be written</param>
        /// <returns>0 for success, non-zero for failure</returns>
        public static int Run(string inputDir, string outputPath)
        {
            Console.WriteLine("Scanning C# files in: " + inputDir);

            string[] csFiles = Directory.GetFiles(inputDir, "*.cs", SearchOption.AllDirectories);
            Dictionary<string, List<ClassDeclarationSyntax>> namespaceGroups = new Dictionary<string, List<ClassDeclarationSyntax>>();
            Dictionary<string, List<EnumDeclarationSyntax>> enumGroups = new Dictionary<string, List<EnumDeclarationSyntax>>();
            Dictionary<ClassDeclarationSyntax, List<ClassDeclarationSyntax>> nestedClassMap = new Dictionary<ClassDeclarationSyntax, List<ClassDeclarationSyntax>>();

            Console.WriteLine("Found " + csFiles.Length + " C# files");

            foreach (string file in csFiles)
            {
                try
                {
                    string code = File.ReadAllText(file);
                    SyntaxTree tree = CSharpSyntaxTree.ParseText(code);
                    CompilationUnitSyntax root = tree.GetCompilationUnitRoot();
                    string ns = "Global";

                    foreach (MemberDeclarationSyntax member in root.Members)
                    {
                        if (member is BaseNamespaceDeclarationSyntax nsDecl)
                        {
                            ns = nsDecl.Name.ToString();
                            break;
                        }
                    }

                    List<ClassDeclarationSyntax> classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();
                    List<EnumDeclarationSyntax> enums = root.DescendantNodes().OfType<EnumDeclarationSyntax>().ToList();

                    foreach (var classDecl in classes)
                    {
                        var nestedClasses = classDecl.DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();
                        if (nestedClasses.Count > 0)
                        {
                            nestedClassMap[classDecl] = nestedClasses;
                        }
                    }

                    // Find top-level classes (not nested within another class)
                    var topLevelClasses = classes.Where(c => !(c.Parent is ClassDeclarationSyntax)).ToList();
                    if (!namespaceGroups.ContainsKey(ns))
                        namespaceGroups[ns] = new List<ClassDeclarationSyntax>();
                    namespaceGroups[ns].AddRange(topLevelClasses);

                    if (!enumGroups.ContainsKey(ns))
                        enumGroups[ns] = new List<EnumDeclarationSyntax>();
                    enumGroups[ns].AddRange(enums);
                }
                catch (Exception ex)
                {
                    Console.ForegroundColor = ConsoleColor.Yellow;
                    Console.WriteLine("Warning: Error processing file " + file + ": " + ex.Message);
                    Console.ResetColor();
                }
            }

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("/**");
            sb.AppendLine(" * TypeScript definitions generated by CsTsTypeGen (https://github.com/kruserr/CsTsTypeGen)");
            sb.AppendLine(" * This file is automatically generated, if you modify this file manually, it will be overwritten.");
            sb.AppendLine(" */");
            sb.AppendLine();

            sb.AppendLine("interface DbSet<T> extends Array<T> {");
            sb.AppendLine("  add(entity: T): void;");
            sb.AppendLine("  remove(entity: T): void;");
            sb.AppendLine("  find(id: any): T | undefined;");
            sb.AppendLine("}\n");

            foreach (KeyValuePair<string, List<ClassDeclarationSyntax>> nsGroup in namespaceGroups)
            {
                string[] nsParts = nsGroup.Key.Split('.');
                for (int i = 0; i < nsParts.Length; i++)
                {
                    string indent = new string(' ', i * 2);
                    sb.AppendLine(indent + "declare namespace " + nsParts[i] + " {");
                }

                string nsIndent = new string(' ', nsParts.Length * 2);
                string currentNamespace = nsGroup.Key;

                if (enumGroups.ContainsKey(nsGroup.Key))
                {
                    foreach (EnumDeclarationSyntax enumNode in enumGroups[nsGroup.Key])
                    {
                        string enumName = enumNode.Identifier.Text;
                        string comment = DocumentationHelper.GetCommentBlock(enumNode);
                        if (!string.IsNullOrEmpty(comment))
                        {
                            sb.AppendLine(nsIndent + "/**");
                            foreach (string line in comment.Split('\n'))
                                sb.AppendLine(nsIndent + " * " + line);
                            sb.AppendLine(nsIndent + " */");
                        }
                        List<string> enumMembers = new List<string>();
                        foreach (var member in enumNode.Members)
                            enumMembers.Add("'" + member.Identifier.Text + "'");

                        sb.AppendLine(nsIndent + "export type " + enumName + " = " + string.Join(" | ", enumMembers) + ";");

                        sb.AppendLine(nsIndent + "export enum " + enumName + "Enum {");
                        foreach (var member in enumNode.Members)
                        {
                            sb.AppendLine(nsIndent + "  " + member.Identifier.Text + ",");
                        }
                        sb.AppendLine(nsIndent + "}\n");
                    }
                }

                foreach (ClassDeclarationSyntax classNode in nsGroup.Value)
                {
                    GenerateInterfaceForClass(sb, nsIndent, classNode, nestedClassMap, currentNamespace);
                }

                for (int i = nsParts.Length - 1; i >= 0; i--)
                {
                    string indent = new string(' ', i * 2);
                    sb.AppendLine(indent + "}");
                }
                sb.AppendLine();
            }

            Directory.CreateDirectory(Path.GetDirectoryName(Path.GetFullPath(outputPath)));
            File.WriteAllText(outputPath, sb.ToString());

            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("âœ… TypeScript definitions written to: " + outputPath);
            Console.ResetColor();
            return 0;
        }

        /// <summary>
        /// Generates a TypeScript interface for a C# class
        /// </summary>
        private static void GenerateInterfaceForClass(StringBuilder sb, string nsIndent, ClassDeclarationSyntax classNode, 
                                                     Dictionary<ClassDeclarationSyntax, List<ClassDeclarationSyntax>> nestedClassMap,
                                                     string currentNamespace)
        {
            string className = classNode.Identifier.Text;
            string comment = DocumentationHelper.GetCommentBlock(classNode);
            if (!string.IsNullOrEmpty(comment))
            {
                sb.AppendLine(nsIndent + "/**");
                foreach (string line in comment.Split('\n'))
                    sb.AppendLine(nsIndent + " * " + line);
                sb.AppendLine(nsIndent + " */");
            }

            sb.AppendLine(nsIndent + "export interface " + className + " {");
            foreach (PropertyDeclarationSyntax prop in classNode.Members.OfType<PropertyDeclarationSyntax>())
            {
                string propName = TypeMapper.ToCamelCase(prop.Identifier.Text);
                string tsType = TypeMapper.MapType(prop.Type.ToString(), className, currentNamespace);
                bool isNullable = DocumentationHelper.IsNullableProperty(prop);
                bool isObsolete = DocumentationHelper.HasObsoleteAttribute(prop);
                string propComment = DocumentationHelper.GetCommentBlock(prop);

                if (isObsolete || !string.IsNullOrEmpty(propComment))
                {
                    sb.AppendLine(nsIndent + "  /**");
                    if (isObsolete)
                        sb.AppendLine(nsIndent + "   * @deprecated This property is marked as obsolete");
                    if (!string.IsNullOrEmpty(propComment))
                    {
                        foreach (string line in propComment.Split('\n'))
                            sb.AppendLine(nsIndent + "   * " + line);
                    }
                    sb.AppendLine(nsIndent + "   */");
                }

                string optionalSuffix = isNullable ? "?" : "";
                sb.AppendLine(nsIndent + "  " + propName + optionalSuffix + ": " + tsType + ";");
            }
            sb.AppendLine(nsIndent + "}\n");

            if (nestedClassMap.ContainsKey(classNode))
            {
                foreach (var nestedClass in nestedClassMap[classNode])
                {
                    string nestedComment = DocumentationHelper.GetCommentBlock(nestedClass);
                    if (!string.IsNullOrEmpty(nestedComment))
                    {
                        sb.AppendLine(nsIndent + "/**");
                        foreach (string line in nestedComment.Split('\n'))
                            sb.AppendLine(nsIndent + " * " + line);
                        sb.AppendLine(nsIndent + " */");
                    }

                    string nestedClassName = nestedClass.Identifier.Text;
                    sb.AppendLine(nsIndent + "export interface " + nestedClassName + " {");
                    
                    foreach (PropertyDeclarationSyntax prop in nestedClass.Members.OfType<PropertyDeclarationSyntax>())
                    {
                        string propName = TypeMapper.ToCamelCase(prop.Identifier.Text);
                        string tsType = TypeMapper.MapType(prop.Type.ToString(), className, currentNamespace);
                        bool isNullable = DocumentationHelper.IsNullableProperty(prop);
                        bool isObsolete = DocumentationHelper.HasObsoleteAttribute(prop);
                        string propComment = DocumentationHelper.GetCommentBlock(prop);

                        if (isObsolete || !string.IsNullOrEmpty(propComment))
                        {
                            sb.AppendLine(nsIndent + "  /**");
                            if (isObsolete)
                                sb.AppendLine(nsIndent + "   * @deprecated This property is marked as obsolete");
                            if (!string.IsNullOrEmpty(propComment))
                            {
                                foreach (string line in propComment.Split('\n'))
                                    sb.AppendLine(nsIndent + "   * " + line);
                            }
                            sb.AppendLine(nsIndent + "   */");
                        }

                        string optionalSuffix = isNullable ? "?" : "";
                        sb.AppendLine(nsIndent + "  " + propName + optionalSuffix + ": " + tsType + ";");
                    }
                    sb.AppendLine(nsIndent + "}\n");
                }
            }
        }
    }
}