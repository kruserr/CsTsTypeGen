using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using System.Text.RegularExpressions;

// Display tool banner
Console.WriteLine("CsTsTypeGen - C# to TypeScript Definition Generator");
Console.WriteLine("====================================================");

// Parse command line arguments and environment variables
// This allows the tool to be used both from command line and via MSBuild properties
string currentDirectory = Environment.CurrentDirectory;
string inputDir = Path.Combine(currentDirectory, "..");  // Default to parent directory
string outputPath = Path.Combine(currentDirectory, "typedefs.d.ts"); // Default in current directory

// Check for MSBuild properties passed as environment variables
var csSourceDir = Environment.GetEnvironmentVariable("CsTsTypeGen_SourceDirectory");
var tsDefinitionsPath = Environment.GetEnvironmentVariable("CsTsTypeGen_DefinitionsPath");
var generateDefinitions = Environment.GetEnvironmentVariable("CsTsTypeGen_GenerateDefinitions");

// If GenerateTypeScriptDefinitions is explicitly set to false, exit early
if (generateDefinitions != null && generateDefinitions.ToLower() == "false")
{
    Console.WriteLine("TypeScript definition generation is disabled. Skipping...");
    return 0;
}

// Command-line arguments take precedence over environment variables
if (args.Length > 0)
{
    inputDir = args[0];
}
else if (!string.IsNullOrEmpty(csSourceDir))
{
    inputDir = csSourceDir;
}

// Output path from command line or environment variable
if (args.Length > 1)
{
    outputPath = args[1];
}
else if (!string.IsNullOrEmpty(tsDefinitionsPath))
{
    outputPath = tsDefinitionsPath;
}

// Validate input directory exists
if (!Directory.Exists(inputDir))
{
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine($"Error: Input directory not found: {inputDir}");
    Console.ResetColor();
    Console.WriteLine("Usage: cstsgen <input-directory> [output-file]");
    Console.WriteLine("  input-directory: Directory containing C# files to scan");
    Console.WriteLine("  output-file:     Path for TypeScript definitions output (default: ./typedefs.d.ts)");
    Console.WriteLine();
    Console.WriteLine("Default configuration:");
    Console.WriteLine("  <GenerateTypeScriptDefinitions>true</GenerateTypeScriptDefinitions>");
    Console.WriteLine("  <TypeScriptDefinitionsPath>$(MSBuildProjectDirectory)/typedefs.d.ts</TypeScriptDefinitionsPath>");
    Console.WriteLine("  <CsTsSourceDirectory>$(MSBuildProjectDirectory)/..</CsTsSourceDirectory>");
    return 1;
}

try
{
    Console.WriteLine($"Scanning C# files in: {inputDir}");
    
    /* Build dictionary of namespaces -> classes */
    var csFiles = Directory.GetFiles(inputDir, "*.cs", SearchOption.AllDirectories);
    var namespaceGroups = new Dictionary<string, List<ClassDeclarationSyntax>>();
    var enumGroups = new Dictionary<string, List<EnumDeclarationSyntax>>();
    
    Console.WriteLine($"Found {csFiles.Length} C# files");
    
    foreach (var file in csFiles)
    {
        try
        {
            var code = File.ReadAllText(file);
            var tree = CSharpSyntaxTree.ParseText(code);
            var root = tree.GetCompilationUnitRoot();
            // Get file-scoped OR traditional namespace
            string ns = root.Members
                .OfType<BaseNamespaceDeclarationSyntax>()
                .FirstOrDefault()?.Name.ToString() ?? "Global";
            var classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();
            var enums = root.DescendantNodes().OfType<EnumDeclarationSyntax>().ToList();
            if (!namespaceGroups.ContainsKey(ns))
                namespaceGroups[ns] = new List<ClassDeclarationSyntax>();
            namespaceGroups[ns].AddRange(classes);
            
            if (!enumGroups.ContainsKey(ns))
                enumGroups[ns] = new List<EnumDeclarationSyntax>();
                
            enumGroups[ns].AddRange(enums);
        }
        catch (Exception ex)
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine($"Warning: Error processing file {file}: {ex.Message}");
            Console.ResetColor();
        }
    }
    
    /* Generate .d.ts content */
    Console.WriteLine("Generating TypeScript definitions...");
    var sb = new StringBuilder();
    
    // Add header comment
    sb.AppendLine("/**");
    sb.AppendLine(" * TypeScript definitions generated by CsTsTypeGen (https://github.com/kruserr/CsTsTypeGen)");
    sb.AppendLine(" * This file is automatically generated, if you modify this file manually, it will be overwritten.");
    sb.AppendLine(" */");
    sb.AppendLine();
    
    // Add DbSet<T> interface declaration at the beginning
    sb.AppendLine("interface DbSet<T> extends Array<T> {");
    sb.AppendLine("  // Entity Framework DbSet interface");
    sb.AppendLine("  add(entity: T): void;");
    sb.AppendLine("  remove(entity: T): void;");
    sb.AppendLine("  find(id: any): T | undefined;");
    sb.AppendLine("}\n");
    
    // Process each namespace
    foreach (var nsGroup in namespaceGroups)
    {
        var nsParts = nsGroup.Key.Split('.');
        for (int i = 0; i < nsParts.Length; i++)
        {
            var indent = new string(' ', i * 2);
            sb.AppendLine($"{indent}declare namespace {nsParts[i]} {{");
        }
        var nsIndent = new string(' ', nsParts.Length * 2);
        
        // First process any enums in this namespace
        if (enumGroups.TryGetValue(nsGroup.Key, out var enums) && enums.Any())
        {
            foreach (var enumNode in enums)
            {
                var enumName = enumNode.Identifier.Text;
                var comment = GetCommentBlock(enumNode);
                if (!string.IsNullOrWhiteSpace(comment))
                {
                    sb.AppendLine($"{nsIndent}/**");
                    foreach (var line in comment.Split('\n'))
                        sb.AppendLine($"{nsIndent} * {line}");
                    sb.AppendLine($"{nsIndent} */");
                }
                // Create a TypeScript union type from the enum
                var enumMembers = enumNode.Members
                    .Select(m => $"'{m.Identifier.Text}'")
                    .ToList();
                    
                sb.AppendLine($"{nsIndent}export type {enumName} = {string.Join(" | ", enumMembers)};");
                
                // Also create an enum object for numeric access
                sb.AppendLine($"{nsIndent}export enum {enumName}Enum {{");
                foreach (var member in enumNode.Members)
                {
                    sb.AppendLine($"{nsIndent}  {member.Identifier.Text},");
                }
                sb.AppendLine($"{nsIndent}}}\n");
            }
        }
        
        // Then process classes 
        foreach (var classNode in nsGroup.Value)
        {
            var className = classNode.Identifier.Text;
            var comment = GetCommentBlock(classNode);
            if (!string.IsNullOrWhiteSpace(comment))
            {
                sb.AppendLine($"{nsIndent}/**");
                foreach (var line in comment.Split('\n'))
                    sb.AppendLine($"{nsIndent} * {line}");
                sb.AppendLine($"{nsIndent} */");
            }
            sb.AppendLine($"{nsIndent}export interface {className} {{");
            foreach (var prop in classNode.Members.OfType<PropertyDeclarationSyntax>())
            {
                var propName = ToCamelCase(prop.Identifier.Text);
                var tsType = MapType(prop.Type.ToString());
                
                // Check if the property is nullable (has ? suffix or nullable annotation)
                bool isNullable = IsNullableProperty(prop);
                
                // Check if the property has [Obsolete] attribute
                bool isObsolete = HasObsoleteAttribute(prop);
                
                var propComment = GetCommentBlock(prop);
                
                if (isObsolete || !string.IsNullOrWhiteSpace(propComment))
                {
                    sb.AppendLine($"{nsIndent}  /**");
                    
                    if (isObsolete)
                    {
                        sb.AppendLine($"{nsIndent}   * @deprecated This property is marked as obsolete");
                    }
                    
                    if (!string.IsNullOrWhiteSpace(propComment))
                    {
                        foreach (var line in propComment.Split('\n'))
                            sb.AppendLine($"{nsIndent}   * {line}");
                    }
                    
                    sb.AppendLine($"{nsIndent}   */");
                }
                // Add ? for optional (nullable) properties
                string optionalSuffix = isNullable ? "?" : "";
                sb.AppendLine($"{nsIndent}  {propName}{optionalSuffix}: {tsType};");
            }
            sb.AppendLine($"{nsIndent}}}\n");
        }
        for (int i = nsParts.Length - 1; i >= 0; i--)
        {
            var indent = new string(' ', i * 2);
            sb.AppendLine($"{indent}}}");
        }
        sb.AppendLine();
    }
    
    // Write the output file
    Directory.CreateDirectory(Path.GetDirectoryName(Path.GetFullPath(outputPath))!);
    File.WriteAllText(outputPath, sb.ToString());
    
    Console.ForegroundColor = ConsoleColor.Green;
    Console.WriteLine($"✅ TypeScript definitions written to: {outputPath}");
    Console.ResetColor();
    
    return 0;
}
catch (Exception ex)
{
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine($"Error: {ex.Message}");
    Console.ResetColor();
    return 1;
}

/* --- Helpers --- */
string MapType(string csharpType)
{
    // Handle nullable types like string? or int?
    bool isNullable = csharpType.EndsWith("?");
    if (isNullable)
    {
        csharpType = csharpType.Substring(0, csharpType.Length - 1);
    }
    // Handle Nullable<T>
    if (csharpType.StartsWith("Nullable<") && csharpType.EndsWith(">"))
    {
        csharpType = csharpType.Substring(9, csharpType.Length - 10);
        isNullable = true; // Not used right now but might be useful later
    }
    // Handle ICollection<T>
    if (csharpType.StartsWith("ICollection<") && csharpType.EndsWith(">"))
    {
        var inner = csharpType.Substring(12, csharpType.Length - 13);
        return MapType(inner) + "[]";
    }
    
    // Keep DbSet<T> as DbSet<T>
    if (csharpType.StartsWith("DbSet<") && csharpType.EndsWith(">"))
    {
        var inner = csharpType.Substring(6, csharpType.Length - 7);
        return "DbSet<" + MapType(inner) + ">";
    }
    // Handle List<T> and IList<T>
    if (csharpType.StartsWith("List<") || csharpType.StartsWith("IList<"))
    {
        var inner = csharpType.Substring(csharpType.IndexOf("<") + 1, csharpType.IndexOf(">") - csharpType.IndexOf("<") - 1);
        return MapType(inner) + "[]";
    }
    return csharpType switch
    {
        "string" => "string",
        "int" or "long" or "decimal" or "double" or "float" => "number",
        "bool" => "boolean",
        "DateTime" or "DateTimeOffset" => "string", // Map to string for ISO 8601 formatted date strings
        "Guid" => "string", // GUIDs are typically string in TS
        _ => csharpType // Assume it's another DTO or enum
    };
}

string ToCamelCase(string input) =>
    string.IsNullOrEmpty(input) ? input : char.ToLowerInvariant(input[0]) + input.Substring(1);

bool IsNullableProperty(PropertyDeclarationSyntax prop)
{
    // Check for ? suffix
    if (prop.Type.ToString().EndsWith("?"))
        return true;
        
    // Check for Nullable<T>
    if (prop.Type.ToString().StartsWith("Nullable<"))
        return true;
        
    // Check for [AllowNull] attribute
    return prop.AttributeLists
        .SelectMany(list => list.Attributes)
        .Any(attr => attr.Name.ToString() == "AllowNull");
}

bool HasObsoleteAttribute(PropertyDeclarationSyntax prop)
{
    // Check for [Obsolete] attribute
    return prop.AttributeLists
        .SelectMany(list => list.Attributes)
        .Any(attr => 
            attr.Name.ToString() == "Obsolete" || 
            attr.Name.ToString() == "ObsoleteAttribute");
}

string? GetCommentBlock(SyntaxNode node)
{
    // Process only the first XML documentation comment
    foreach (var trivia in node.GetLeadingTrivia())
    {
        if (trivia.GetStructure() is DocumentationCommentTriviaSyntax doc)
        {
            var docLines = new List<string>();
            
            // Extract summary
            var summary = doc.ChildNodes()
                .OfType<XmlElementSyntax>()
                .FirstOrDefault(e => e.StartTag.Name.LocalName.Text == "summary");
            if (summary != null)
            {
                var summaryText = ExtractTextFromXmlNode(summary);
                if (!string.IsNullOrWhiteSpace(summaryText))
                {
                    docLines.Add(summaryText);
                }
            }
            
            // Extract code blocks (but not other remarks content)
            var codeBlocks = doc.DescendantNodes()
                .OfType<XmlElementSyntax>()
                .Where(e => e.StartTag.Name.LocalName.Text == "code")
                .ToList();
                
            if (codeBlocks.Any())
            {
                foreach (var codeBlock in codeBlocks)
                {
                    docLines.Add("");
                    docLines.Add("```csharp");
                    var codeLines = ProcessCodeBlock(codeBlock);
                    docLines.AddRange(codeLines);
                    docLines.Add("```");
                }
            }
            
            // Clean up the entire result to remove any lingering XML tags
            var result = string.Join("\n", docLines);
            
            // Remove any lingering XML closing tags
            result = Regex.Replace(result, @"</?code>|</?remarks>", "");
            
            return result.Trim();
        }
    }
    // Fallback to regular comments if no XML doc is found
    var regularComments = node.GetLeadingTrivia()
        .Where(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia))
        .Select(t => t.ToString().TrimStart('/').Trim());
    if (regularComments.Any())
        return string.Join("\n", regularComments);
    return null;
}

string ExtractTextFromXmlNode(XmlElementSyntax element)
{
    var text = element.Content.ToFullString();
    // Remove XML comment markers
    text = Regex.Replace(text, @"^\s*///\s*", "", RegexOptions.Multiline);
    // Remove any XML tags
    text = Regex.Replace(text, @"<.*?>", "");
    return text.Trim();
}

List<string> ProcessCodeBlock(XmlElementSyntax codeBlock)
{
    var result = new List<string>();
    
    // Get the raw text content of the code block
    string codeContent = codeBlock.Content.ToFullString();
    
    // Split into lines and process
    var lines = codeContent.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
    
    foreach (var line in lines)
    {
        // Clean any XML comment markers and preserve indentation
        var cleaned = Regex.Replace(line, @"^\s*///\s?", "");
        
        // Skip empty lines at the beginning or end
        if (string.IsNullOrWhiteSpace(cleaned) && 
            (result.Count == 0 || line == lines.Last()))
            continue;
        
        result.Add(cleaned);
    }
    
    return result;
}
